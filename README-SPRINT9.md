Прорабатываем логику API
Ваша задача — реализовать API, в котором эндпоинты будут соответствовать вызовам базовых методов интерфейса TaskManager.
Например, вызову метода getTasks() будет соответствовать эндпоинт GET /tasks. Такое соответствие эндпоинтов и методов
называют маппингом (от англ. mapping).
Все методы TaskManager можно разделить на пять групп. Это методы для работы с обычными задачами, подзадачами, эпиками, а
также с историей и списком задач в порядке приоритета.
Каждой группе в API должен соответствовать свой путь — так интерфейс будет максимально удобным и понятным для
пользователя. Следовательно, базовые пути приложения будут следующие: /tasks, /subtasks, /epics, /history и
/prioritized.
Для выполнения разных операций с данными для одного и того же пути используют разные HTTP-методы. Так, для запросов на
чтение данных (например, для получения списка задач) используют метод GET, для модификации данных (например, для
добавления новой задачи или изменения существующей) — POST, а для удаления данных (например, для удаления задачи) —
DELETE.
Не забудьте о статусах ответа, которые сервер будет возвращать пользователю. Начнём с кодов успеха:

    если сервер корректно выполнил запрос и вернул данные — код 200;
    если запрос выполнен успешно, но возвращать данные нет необходимости (так бывает в запросах на их модификацию) — код 201.

На случай проблем с запросами пользователя пригодятся коды ошибок — их будет три:

    если пользователь обратился к несуществующему ресурсу (например, попытался получить задачу, которой нет) — статус 404 (Not Found);
    если добавляемая задача пересекается с существующими — статус 406 (Not Acceptable);
    если произошла ошибка при обработке запроса (например, при сохранении данных менеджера в файл) — статус 500 (Internal Server Error).

Осталось определить формат, в котором данные будут передаваться между клиентом и сервером. Стандартным считается формат
JSON — используйте его.
Подведём итог и опишем ожидаемый API в виде таблицы.

Продумываем реализацию
Теперь, когда вы определились с API, можно переходить к его реализации. Вот что нужно сделать:

    Создайте класс HttpTaskServer — он будет слушать порт 8080 и принимать запросы. Это будет основной класс вашего 
    приложения. В нём должен находиться метод main, который будет запускаться для начала работы с программой.
    Чтобы приложение могло принимать и обрабатывать запросы пользователя, используйте класс HttpServer. При запуске 
    программы должен стартовать экземпляр HttpServer.
    Для каждого из пяти базовых путей создайте свой обработчик. Затем привяжите его к соответствующему пути.
    Добавьте в проект библиотеку Gson для работы с JSON. Она пригодится в обработчиках для парсинга данных пользователя. 
    И наоборот — для возвращения пользователю результатов запроса.
    Добавьте в сервер работу с менеджером задач. Используйте утилитарный класс Managers, чтобы получить экземпляр менеджера. 
    Учтите, что в обработчиках должен быть доступ к этому экземпляру — подумайте, как это лучше реализовать.
    В обработчиках реализуйте обработку запросов пользователя, а также обращение к соответствующим методам менеджера 
    задач согласно спецификации.
    Чтобы не дублировать код, можно использовать общий для всех HTTP-обработчиков класс. Для этого создайте класс 
    BaseHttpHandler — он будет содержать общие методы для чтения и отправки данных:
     
        sendText — для отправки общего ответа в случае успеха;
        sendNotFound — для отправки ответа в случае, если объект не был найден;
        sendHasInteractions — для отправки ответа, если при создании или обновлении задача пересекается с уже существующими.

Подсказка: пример класса BaseHttpHandler и метода sendText

package ru.yandex.javacourse.schedule.http.handler;

import com.sun.net.httpserver.HttpExchange;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

public class BaseHttpHandler {
protected void sendText(HttpExchange h, String text) throws IOException {
byte[] resp = text.getBytes(StandardCharsets.UTF_8);
h.getResponseHeaders().add("Content-Type", "application/json;charset=utf-8");
h.sendResponseHeaders(200, resp.length);
h.getResponseBody().write(resp);
h.close();
}
}

В этом случае подклассы-обработчики TaskHandler или UserHandler будут наследоваться от BaseHttpHandler, чтобы
использовать общие методы. Такой подход уменьшает количество повторяющегося кода и позволяет проще вносить в него
изменения.

    Код можно сделать ещё лаконичнее, пробрасывая NotFoundException в TaskManager. Тогда в обработчиках не нужно проверять 
    экземпляр Task на null — можно обрабатывать сразу исключение. Реализуйте такой подход. Также добавьте try — catch — 
    он будет обрабатывать все исключения, которые возникают во время работы программы.

Убедитесь, что API приложения функционирует корректно. Для проверки используйте инструменты Insomnia или Postman.
Принципы работы с этими программами схожи, так что, если вы знаете, как использовать одну, вам не составит труда освоить
другую.
Пишем тесты
Осталось реализовать unit-тесты для разработанного HTTP-интерфейса. Можно использовать следующий алгоритм для каждого
теста:

    Создайте экземпляр HttpTaskServer и запустите HTTP-сервер. Подумайте, как лучше спроектировать класс HttpTaskServer, 
    чтобы сервер было удобно запускать как конечному пользователю, так и для тестирования.

Подсказка: как удобно запускать сервер
Можно создать отдельный метод start() в классе HttpTaskServer и вызывать его и из метода main, и из тестов.

    В тестах для HttpTaskServer используйте InMemoryTaskManager в качестве зависимости для конструктора HttpTaskServer, 
    чтобы имитировать реальное хранение и обработку данных.
    Выполните проверки. В зависимости от задачи они могут быть разными — например, убедиться, что добавленная задача 
    успешно сохранилась в менеджере.
    Остановите HTTP-сервер. Это важно: если сервер не остановить, его будет невозможно запустить ещё раз на том же порту.

Подсказка: как остановить сервер
Поступите так же, как и с запуском: создайте в классе HttpTaskServer метод stop().

Так как код запуска и остановки сервера будет дублироваться в каждом тесте, этот код можно вынести в отдельные методы и
пометить их аннотациями @BeforeEach и @AfterEach.
Напишите тесты для каждого эндпоинта HttpTaskServer. Обязательно проверьте в каждом из тестов статус ответа — отдельно
для успешного и неуспешного сценариев.
Чтобы с кодом тестов было проще работать, мы рекомендуем разбить их на несколько классов — для каждого из базовых путей.

Для тестирования логики по добавлению задачи и её сохранению в InMemoryTaskManager можно создать следующий тест:

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class HttpTaskManagerTasksTest {

    // создаём экземпляр InMemoryTaskManager
    TaskManager manager = new InMemoryTaskManager();
    // передаём его в качестве аргумента в конструктор HttpTaskServer
    HttpTaskServer taskServer = new HttpTaskServer(manager);
    Gson gson = HttpTaskServer.getGson();

    public HttpTaskManagerTasksTest() throws IOException {
    }

    @BeforeEach
    public void setUp() {
        manager.deleteTasks();
        manager.deleteSubtasks();
        manager.deleteEpics();
        taskServer.start();
    }

    @AfterEach
    public void shutDown() {
        taskServer.stop();
    }

    @Test
    public void testAddTask() throws IOException, InterruptedException {
        // создаём задачу
        Task task = new Task("Test 2", "Testing task 2",
                TaskStatus.NEW, Duration.ofMinutes(5), LocalDateTime.now());
        // конвертируем её в JSON
        String taskJson = gson.toJson(task);

        // создаём HTTP-клиент и запрос
        HttpClient client = HttpClient.newHttpClient();
        URI url = URI.create("http://localhost:8080/tasks");
        HttpRequest request = HttpRequest.newBuilder().uri(url).POST(HttpRequest.BodyPublishers.ofString(taskJson)).build();

        // вызываем рест, отвечающий за создание задач
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        // проверяем код ответа
        assertEquals(200, response.statusCode());

        // проверяем, что создалась одна задача с корректным именем
        List<Task> tasksFromManager = manager.getTasks();

        assertNotNull(tasksFromManager, "Задачи не возвращаются");
        assertEquals(1, tasksFromManager.size(), "Некорректное количество задач");
        assertEquals("Test 2", tasksFromManager.get(0).getName(), "Некорректное имя задачи");
    }

}

В этом тесте мы отправляем HTTP-запрос для создания новой задачи и проверяем, что она появилась в InMemoryTaskManager.
Методы setUp() и shutDown() помогают запускать и останавливать сервер до и после каждого теста.

Дополнительная рекомендация: о тестах
Вы можете захотеть проверить сразу несколько сценариев в одном тесте — например, создание задачи, её обновление и
удаление. Мы не рекомендуем такой подход. Чем больше сценариев проверяет тест, тем выше вероятность, что он «упадёт», и
тогда будет сложно понять, на каком именно этапе возникла ошибка.
Лучше, когда один тест сфокусирован на одной области функциональности. А ещё когда у него информативное название, тогда,
даже если он «упадёт», вы сможете сразу понять, где искать ошибку.