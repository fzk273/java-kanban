Техническое задание
Время практики! В этом спринте вы добавите новую функциональность: трекер задач сможет расставлять задачи по приоритету
и проверять, не пересекаются ли они по времени выполнения. Дополнительно нужно будет написать ещё несколько тестов — для
новых функциональностей и не только. Вперёд!
Подготавливаем ветку
Для выполнения задания этого спринта создайте в локальном репозитории ветку с названием
sprint_8-solution-time-and-duration.
Добавляем продолжительность и дату старта
Добавьте новые поля и методы в задачи:

    duration — продолжительность задачи, оценка того, сколько времени она займёт в минутах. Это значение требуется 
    хранить в экземпляре класса Duration.
    startTime — дата и время, когда предполагается приступить к выполнению задачи. Здесь лучше всего подойдёт LocalDateTime.
    getEndTime() — дата и время завершения задачи, которые рассчитываются исходя из startTime и duration.

Менять сигнатуры методов интерфейса TaskManager не понадобится: при создании или обновлении задач все его методы будут
принимать и возвращать объект, в который вы добавите два новых поля.
А вот с классом Epic нужно поработать дополнительно. Продолжительность эпика — сумма продолжительностей всех его
подзадач. Время начала — дата старта самой ранней подзадачи, а время завершения — время окончания самой поздней из
задач. Новые поля duration и startTime этого класса будут расчётные — аналогично полю «статус». Для реализации
getEndTime() удобно добавить поле endTime в Epic и рассчитать его вместе с другими полями.
Также не забудьте:

    доработать опцию сохранения состояния в файл — добавьте в методы сериализации/десериализации новые поля;
    добавить в тесты проверку новых полей (иначе IntelliJ IDEA не скомпилирует проект из-за возможных изменений в методах).

Подсказка: про поле duration
При сохранении поля duration его можно переводить в количество минут, а при загрузке — из минут преобразовывать в объект
класса Duration.

Выводим список задач в порядке приоритета
Отсортируйте все задачи по приоритету — то есть по startTime. Напишите новый метод getPrioritizedTasks, возвращающий
список задач и подзадач в заданном порядке.
Предполагается, что пользователь будет часто запрашивать этот список, поэтому подберите подходящую структуру данных для
хранения. Сложность получения должна быть уменьшена с O(n∗log(n))O(n∗log(n)) до O(n)O(n).

Подсказка: как ускорить сортировку
Если сортировать список заново каждый раз, сложность получения будет O(n∗log(n))O(n∗log(n)). Можно хранить все задачи
заранее отсортированными с помощью класса TreeSet.

Дата начала задачи по каким-то причинам может быть не задана. Тогда при добавлении её не следует учитывать в списке
задач и подзадач, отсортированных по времени начала. Такая задача не влияет на приоритет других, а при попадании в
список может сломать логику работы компаратора.
Проверяем пересечения с помощью Stream API
Предполагается, что пользователь будет выполнять не более одной задачи за раз. Научите трекер проверять, что задачи и
подзадачи не пересекаются по времени выполнения:

    Добавьте валидацию во время создания или изменения задач и подзадач.
    Реализуйте метод, который будет проверять, пересекаются ли две задачи по времени выполнения, и возвращать true или 
    false. Для его реализации используйте математический метод наложения отрезков.
    В методе add выполните проверку, пересекается ли добавляемая задача с любой другой в списке менеджера. Для этого 
    используйте Stream API и метод, который вы реализовали в предыдущем пункте.

Подсказки
Как проверить, пересекаются ли две задачи, с помощью метода наложения отрезков
Проверить, пересекаются ли отрезки (то есть линии от начала до конца задачи на оси времени), вам поможет эта схема.

Как искать пересечения за O(n)
getPrioritizedTasks возвращает отсортированный список задач. По нему можно пройтись за O(n)O(n) и проверить все задачи
на пересечение.

Меняем циклы на Stream API
В некоторых местах кода вы использовали разные циклы foreach — например, в методе TaskManager.getEpicSubtasks(int
epicId). С помощью Stream API преобразуйте операции в этих методах и избавьтесь от временных переменных.
Покрываем код тестами
Ваша цель — написать отдельный тест для оставшихся публичных методов: стандартный кейс работы и граничные случаи.
Потребуются следующие тесты.

    Для расчёта статуса Epic. Граничные условия:
     a. Все подзадачи со статусом NEW.
     b. Все подзадачи со статусом DONE.
     c. Подзадачи со статусами NEW и DONE. 
     d. Подзадачи со статусом IN_PROGRESS.
    Чтобы протестировать реализации менеджера задач — InMemoryTaskManager и FileBackedTaskManager, необходимо выполнить 
    следующие шаги:
        Создать базовый класс для тестов:
            Добавить абстрактный класс abstract class TaskManagerTest<T extends TaskManager>, который будет содержать 
            тесты для методов интерфейса TaskManager.
            Это позволит избавиться от дублирующегося кода в классах FileBackedTaskManagerTest, InMemoryHistoryManagerTest 
            и InMemoryTaskManagerTest. В этих классах останутся только тесты, относящиеся к специфическим методам 
            конкретной реализации менеджера задач.
        Проверка подзадач и эпиков:
            Для подзадач необходимо дополнительно убедиться в наличии связанного эпика.
            Для эпиков нужно проверить корректность расчёта статуса на основании состояния подзадач.
        Добавить тест на проверку пересечения интервалов:
            Убедиться, что реализован корректный расчёт пересечения временных интервалов задач, чтобы предотвратить 
            конфликтные ситуации.
    Для HistoryManager — тесты для всех методов интерфейса. Граничные условия:
     a. Пустая история задач.
     b. Дублирование.
     c. Удаление из истории: начало, середина, конец.
    Корректный перехват исключений при работе с файлами: для этого используйте утилитарные методы JUnit — 
    Assertions.assertThrows(…) и Assertions.assertDoesNotThrow(…). Эти методы получают на вход класс-исключение и 
    экземпляр анонимного класса/лямбду. В единственном методе реализуется вызов того кода, который потенциально может 
    вызвать исключение. Например:

@Test
public void testException() {
assertThrows(ArithmeticException.class, () -> {
int a = 10 / 0;
}, "Деление на ноль должно приводить к исключению");
}

После написания тестов ещё раз проверьте их наличие по списку. Убедитесь, что они работают.

Дополнительные задания
А теперь необязательные задания для тех, кто хочет бросить себе вызов! Если у вас останется время, вы можете выполнить
одно из них или сразу оба.

    Используйте тип Optional, чтобы возвращать результат методов поиска задачи/подзадачи по id.
    Подумайте, какая структура данных и какой алгоритм проверки подойдут, чтобы уменьшить сложность поиска пересечений 
    до O(1)O(1).

Подсказка: как искать пересечения за O(1)
Пусть все задачи располагаются на сетке с интервалами в 1515 минут, а планирование возможно только на год вперёд. В этом
случае можно заранее заполнить таблицу, где ключ — это интервал, а значение — объект boolean (свободно время или нет). В
итоге для эффективного поиска пересечений достаточно будет проверить, что свободны все 1515-минутные интервалы задачи.
Не забудьте перепроверить код перед отправкой на ревью!
Интересного вам программирования!
